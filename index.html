<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Leonâ€™s Platformer</title>
<style>
  body { margin:0; overflow:hidden; background:linear-gradient(to bottom,#87CEEB,#E0F7FA); font-family:'Arial Rounded MT Bold','Arial',sans-serif;}
  canvas{display:block;}
  #ui{position:absolute;top:20px;left:20px;background:rgba(255,255,255,0.8);padding:15px;border-radius:10px;box-shadow:0 0 10px rgba(0,0,0,0.2);}
  #score{position:absolute;top:20px;right:20px;background:rgba(0,0,0,0.7);color:white;padding:10px 15px;border-radius:20px;font-size:18px;}
  #highScore{position:absolute;top:60px;right:20px;background:rgba(0,0,0,0.7);color:white;padding:10px 15px;border-radius:20px;font-size:18px;}
  #gameOver{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);background:rgba(255,255,255,0.95);padding:30px;border-radius:15px;text-align:center;box-shadow:0 0 30px rgba(0,0,0,0.3);display:none;z-index:100;}
  button{background:#4CAF50;color:white;border:none;padding:12px 25px;border-radius:25px;font-size:16px;cursor:pointer;margin-top:15px;transition:background 0.3s;}
  button:hover{background:#388E3C;}
  
  /* Background toggle button */
  #bgToggle {
    background: rgba(0, 0, 0, 0.7);
    color: white;
    border: none;
    padding: 10px 15px;
    border-radius: 20px;
    font-size: 14px;
    cursor: pointer;
    transition: all 0.3s;
    margin: 10px 5px;
  }
  
  #bgToggle:hover {
    background: rgba(0, 0, 0, 0.9);
    transform: scale(1.05);
  }
  
  #bgToggle.off {
    background: rgba(255, 255, 255, 0.8);
    color: #333;
  }
  
  #bgToggle.off:hover {
    background: rgba(255, 255, 255, 0.9);
  }
  
  /* Menu button */
  #menuBtn {
    position: absolute;
    bottom: 20px;
    right: 20px;
    background: rgba(255, 0, 0, 0.7);
    color: white;
    border: none;
    padding: 10px 20px;
    border-radius: 20px;
    font-size: 14px;
    cursor: pointer;
    z-index: 50;
    transition: all 0.3s;
  }
  
  #menuBtn:hover {
    background: rgba(255, 0, 0, 0.9);
    transform: scale(1.05);
  }
  
  /* Character selection styles */
  .character-selection {
    margin: 20px 0;
    padding: 15px;
    background: rgba(0, 0, 0, 0.05);
    border-radius: 10px;
  }
  
  .character-selection h3 {
    margin: 0 0 15px 0;
    color: #333;
  }
  
  .character-preview {
    display: flex;
    flex-direction: column;
    align-items: center;
    margin-bottom: 15px;
  }
  
  .preview-canvas-container {
    width: 80px;
    height: 80px;
    margin-bottom: 10px;
    border-radius: 10px;
    background: rgba(0, 0, 0, 0.1);
    display: flex;
    align-items: center;
    justify-content: center;
    box-shadow: 0 3px 8px rgba(0,0,0,0.2);
  }
  
  .preview-canvas {
    width: 60px;
    height: 60px;
  }
  
  .color-options {
    display: flex;
    justify-content: center;
    flex-wrap: wrap;
    gap: 10px;
    margin-top: 10px;
  }
  
  .color-option {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    cursor: pointer;
    border: 3px solid transparent;
    transition: all 0.2s;
    box-shadow: 0 2px 5px rgba(0,0,0,0.2);
  }
  
  .color-option:hover {
    transform: scale(1.1);
  }
  
  .color-option.selected {
    border: 3px solid #333;
    transform: scale(1.1);
  }
  
  /* Background theme selection styles */
  .theme-selection {
    margin: 20px 0;
    padding: 15px;
    background: rgba(0, 0, 0, 0.05);
    border-radius: 10px;
  }
  
  .theme-selection h3 {
    margin: 0 0 15px 0;
    color: #333;
  }
  
  .theme-preview {
    display: flex;
    flex-direction: column;
    align-items: center;
    margin-bottom: 15px;
  }
  
  .theme-preview-canvas-container {
    width: 120px;
    height: 80px;
    margin-bottom: 10px;
    border-radius: 10px;
    overflow: hidden;
    box-shadow: 0 3px 8px rgba(0,0,0,0.2);
    border: 2px solid rgba(0,0,0,0.1);
  }
  
  .theme-preview-canvas {
    width: 120px;
    height: 80px;
  }
  
  .theme-options {
    display: flex;
    justify-content: center;
    flex-wrap: wrap;
    gap: 10px;
    margin-top: 10px;
  }
  
  .theme-option {
    width: 50px;
    height: 50px;
    border-radius: 8px;
    cursor: pointer;
    border: 3px solid transparent;
    transition: all 0.2s;
    box-shadow: 0 2px 5px rgba(0,0,0,0.2);
    overflow: hidden;
    position: relative;
  }
  
  .theme-option:hover {
    transform: scale(1.1);
  }
  
  .theme-option.selected {
    border: 3px solid #333;
    transform: scale(1.1);
  }
  
  .theme-gradient {
    width: 100%;
    height: 100%;
  }
</style>
</head>
<body>
<canvas id="gameCanvas"></canvas>
<div id="ui">
<h2>Controls</h2>
<p>SPACE / UP / TAP to jump</p>
<p>Hold longer to jump higher</p>
</div>
<div id="score">Score: 0</div>
<div id="highScore">High Score: 0</div>
<button id="menuBtn">Menu</button>
<div id="gameOver">
<h2>Game Over!</h2>
<p>Your score: <span id="finalScore">0</span></p>
<p>High Score: <span id="finalHighScore">0</span></p>
<p>Total Jumps: <span id="totalJumps">0</span></p>
  
<div class="character-selection">
  <h3>Choose Character Color</h3>
  <div class="character-preview">
    <div class="preview-canvas-container">
      <canvas class="preview-canvas" id="characterPreview"></canvas>
    </div>
    <p>Your Character</p>
  </div>
  <div class="color-options">
    <div class="color-option selected" style="background-color: #FF5252;" data-color="#FF5252"></div>
    <div class="color-option" style="background-color: #4CAF50;" data-color="#4CAF50"></div>
    <div class="color-option" style="background-color: #2196F3;" data-color="#2196F3"></div>
    <div class="color-option" style="background-color: #FF9800;" data-color="#FF9800"></div>
    <div class="color-option" style="background-color: #9C27B0;" data-color="#9C27B0"></div>
    <div class="color-option" style="background-color: #00BCD4;" data-color="#00BCD4"></div>
    <div class="color-option" style="background-color: #FFEB3B;" data-color="#FFEB3B"></div>
    <div class="color-option" style="background-color: #795548;" data-color="#795548"></div>
  </div>
</div>

<div class="theme-selection">
  <h3>Choose Background Theme</h3>
  <div class="theme-preview">
    <div class="theme-preview-canvas-container">
      <canvas class="theme-preview-canvas" id="themePreview"></canvas>
    </div>
    <p>Background Preview</p>
  </div>
  <div class="theme-options">
    <div class="theme-option selected" data-theme="default">
      <div class="theme-gradient" style="background: linear-gradient(to bottom, #87CEEB, #E0F7FA);"></div>
    </div>
    <div class="theme-option" data-theme="sunset">
      <div class="theme-gradient" style="background: linear-gradient(to bottom, #FF7E5F, #FEB47B);"></div>
    </div>
    <div class="theme-option" data-theme="ocean">
      <div class="theme-gradient" style="background: linear-gradient(to bottom, #4DA0B0, #D39D38);"></div>
    </div>
    <div class="theme-option" data-theme="forest">
      <div class="theme-gradient" style="background: linear-gradient(to bottom, #667eea, #764ba2);"></div>
    </div>
    <div class="theme-option" data-theme="desert">
      <div class="theme-gradient" style="background: linear-gradient(to bottom, #D1913C, #FFD194);"></div>
    </div>
    <div class="theme-option" data-theme="night">
      <div class="theme-gradient" style="background: linear-gradient(to bottom, #0F2027, #203A43, #2C5364);"></div>
    </div>
  </div>
</div>
  
<button id="playAgainBtn">Play Again</button>
<button id="bgToggle">Background: ON</button>
</div>

<script>
let canvas, ctx;
let player, platforms, particles;
let score = 0, scrollSpeed = 4;
let platformGap = 220, platformMinWidth = 120, platformMaxWidth = 200;
let gameRunning = true, animationId;
let highScore = 0;
let currentGameJumps = 0;
let totalJumps = 0;

// Background elements and toggle state
let mountains = [];
let clouds = [];
let backgroundEnabled = true;

// Character color
let playerColor = "#FF5252";

// Background theme
let currentTheme = "default";
const themes = {
  default: { top: '#87CEEB', bottom: '#E0F7FA' },
  sunset: { top: '#FF7E5F', bottom: '#FEB47B' },
  ocean: { top: '#4DA0B0', bottom: '#D39D38' },
  forest: { top: '#667eea', bottom: '#764ba2' },
  desert: { top: '#D1913C', bottom: '#FFD194' },
  night: { top: '#0F2027', bottom: '#203A43', mid: '#2C5364' }
};

function initGame(){
  canvas = document.getElementById("gameCanvas");
  ctx = canvas.getContext("2d");
  resizeCanvas();

  // Load saved data
  highScore = localStorage.getItem("highScore") ? parseInt(localStorage.getItem("highScore")) : 0;
  totalJumps = localStorage.getItem("totalJumps") ? parseInt(localStorage.getItem("totalJumps")) : 0;
  
  // Load background preference
  backgroundEnabled = localStorage.getItem("backgroundEnabled") !== "false";
  
  // Load player color preference
  playerColor = localStorage.getItem("playerColor") || "#FF5252";
  
  // Load theme preference
  currentTheme = localStorage.getItem("theme") || "default";
  
  document.getElementById('highScore').textContent = "High Score: " + highScore;

  player = {
    x: canvas.width/2-20,
    y: canvas.height-150,
    width: 40,
    height: 40,
    color: playerColor,
    dy: 0,
    gravity: 0.5,
    jumpPower: -14,
    onGround: false,
    jumpHeld: false,
    jumpFrameCount: 0,
    minJumpPower: -10,
    maxJumpPower: -16,
    hasJumped: false,      
    maxJumpCap: -28
  };

  platforms = []; 
  particles = [];
  createInitialPlatforms();
  
  // Initialize background elements
  initBackground();

  // Set up background toggle button with current state
  updateToggleButton();
  
  // Set up character color selection
  setupCharacterSelection();
  
  // Set up theme selection
  setupThemeSelection();

  // Remove existing event listeners to prevent duplicates
  document.removeEventListener("keydown", handleKeyDown);
  document.removeEventListener("keyup", handleKeyUp);
  document.removeEventListener("mousedown", handleMouseDown);
  document.removeEventListener("mouseup", handleMouseUp);
  document.removeEventListener("touchstart", handleMouseDown);
  document.removeEventListener("touchend", handleMouseUp);
  document.getElementById('playAgainBtn').removeEventListener('click', resetGame);
  document.getElementById('menuBtn').removeEventListener('click', showMenu);
  window.removeEventListener('resize', resizeCanvas);
  document.getElementById('bgToggle').removeEventListener('click', toggleBackground);

  // Add event listeners
  document.addEventListener("keydown", handleKeyDown);
  document.addEventListener("keyup", handleKeyUp);
  document.addEventListener("mousedown", handleMouseDown);
  document.addEventListener("mouseup", handleMouseUp);
  document.addEventListener("touchstart", handleMouseDown);
  document.addEventListener("touchend", handleMouseUp);
  document.getElementById('playAgainBtn').addEventListener('click', resetGame);
  document.getElementById('menuBtn').addEventListener('click', showMenu);
  window.addEventListener('resize', resizeCanvas);
  document.getElementById('bgToggle').addEventListener('click', toggleBackground);

  score = 0; 
  currentGameJumps = 0;
  document.getElementById('score').textContent = 'Score: 0';
  document.getElementById('gameOver').style.display='none';
  gameRunning = true;
  if(animationId) cancelAnimationFrame(animationId);
  gameLoop();
}

function setupCharacterSelection() {
  const colorOptions = document.querySelectorAll('.color-option');
  
  // Remove existing event listeners
  colorOptions.forEach(option => {
    option.replaceWith(option.cloneNode(true));
  });
  
  // Get fresh references
  const freshColorOptions = document.querySelectorAll('.color-option');
  
  // Set initial selected state
  freshColorOptions.forEach(option => {
    if (option.getAttribute('data-color') === playerColor) {
      option.classList.add('selected');
    } else {
      option.classList.remove('selected');
    }
    
    // Add click event
    option.addEventListener('click', function() {
      // Remove selected class from all options
      freshColorOptions.forEach(opt => opt.classList.remove('selected'));
      
      // Add selected class to clicked option
      this.classList.add('selected');
      
      // Update player color
      playerColor = this.getAttribute('data-color');
      localStorage.setItem("playerColor", playerColor);
      
      // Update current player color if game is running
      if (player) {
        player.color = playerColor;
      }
      
      // Update the character preview
      updateCharacterPreview();
    });
  });
  
  // Initialize the character preview
  updateCharacterPreview();
}

function setupThemeSelection() {
  const themeOptions = document.querySelectorAll('.theme-option');
  
  // Remove existing event listeners
  themeOptions.forEach(option => {
    option.replaceWith(option.cloneNode(true));
  });
  
  // Get fresh references
  const freshThemeOptions = document.querySelectorAll('.theme-option');
  
  // Set initial selected state
  freshThemeOptions.forEach(option => {
    if (option.getAttribute('data-theme') === currentTheme) {
      option.classList.add('selected');
    } else {
      option.classList.remove('selected');
    }
    
    // Add click event
    option.addEventListener('click', function() {
      // Remove selected class from all options
      freshThemeOptions.forEach(opt => opt.classList.remove('selected'));
      
      // Add selected class to clicked option
      this.classList.add('selected');
      
      // Update theme
      currentTheme = this.getAttribute('data-theme');
      localStorage.setItem("theme", currentTheme);
      
      // Update the theme preview
      updateThemePreview();
      
      // If we're in the game over screen, update the actual background
      if (!gameRunning) {
        drawBackground();
      }
    });
  });
  
  // Initialize the theme preview
  updateThemePreview();
}

function updateCharacterPreview() {
  const previewCanvas = document.getElementById('characterPreview');
  const previewCtx = previewCanvas.getContext('2d');
  
  // Set canvas size
  previewCanvas.width = 60;
  previewCanvas.height = 60;
  
  // Clear the canvas
  previewCtx.clearRect(0, 0, previewCanvas.width, previewCanvas.height);
  
  // Draw the character in the selected color
  drawPreviewCharacter(previewCtx, playerColor);
}

function updateThemePreview() {
  const previewCanvas = document.getElementById('themePreview');
  const previewCtx = previewCanvas.getContext('2d');
  
  // Set canvas size
  previewCanvas.width = 120;
  previewCanvas.height = 80;
  
  // Clear the canvas
  previewCtx.clearRect(0, 0, previewCanvas.width, previewCanvas.height);
  
  // Draw the theme preview
  const theme = themes[currentTheme];
  let gradient;
  
  if (currentTheme === 'night') {
    // Special handling for night theme with 3 colors
    gradient = previewCtx.createLinearGradient(0, 0, 0, previewCanvas.height);
    gradient.addColorStop(0, theme.top);
    gradient.addColorStop(0.5, theme.mid);
    gradient.addColorStop(1, theme.bottom);
  } else {
    gradient = previewCtx.createLinearGradient(0, 0, 0, previewCanvas.height);
    gradient.addColorStop(0, theme.top);
    gradient.addColorStop(1, theme.bottom);
  }
  
  previewCtx.fillStyle = gradient;
  previewCtx.fillRect(0, 0, previewCanvas.width, previewCanvas.height);
  
  // Add some simple elements to make it look like a game background
  previewCtx.fillStyle = 'rgba(255, 255, 255, 0.3)';
  previewCtx.beginPath();
  previewCtx.arc(30, 20, 10, 0, Math.PI * 2);
  previewCtx.fill();
  
  previewCtx.beginPath();
  previewCtx.arc(80, 30, 8, 0, Math.PI * 2);
  previewCtx.fill();
  
  // Draw a simple ground line
  previewCtx.fillStyle = '#4CAF50';
  previewCtx.fillRect(0, previewCanvas.height - 15, previewCanvas.width, 15);
}

function drawPreviewCharacter(ctx, color) {
  // Draw the character (similar to drawPlayer but scaled down)
  const centerX = ctx.canvas.width / 2;
  const centerY = ctx.canvas.height / 2;
  const size = 30; // Smaller size for preview
  
  ctx.save();
  
  // Draw the main character body
  drawRoundedRectPreview(ctx, centerX - size/2, centerY - size/2, size, size, 5, color);
  
  // Draw eyes
  ctx.fillStyle = "#333";
  ctx.beginPath();
  ctx.arc(centerX - size/2 + size*0.7, centerY - size/2 + size*0.3, 3, 0, Math.PI*2);
  ctx.fill();
  
  ctx.fillStyle = "#FFF";
  ctx.beginPath();
  ctx.arc(centerX - size/2 + size*0.68, centerY - size/2 + size*0.28, 1.5, 0, Math.PI*2);
  ctx.fill();
  
  ctx.restore();
}

function drawRoundedRectPreview(ctx, x, y, w, h, r, color) {
  ctx.beginPath();
  ctx.moveTo(x + r, y);
  ctx.lineTo(x + w - r, y);
  ctx.quadraticCurveTo(x + w, y, x + w, y + r);
  ctx.lineTo(x + w, y + h - r);
  ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
  ctx.lineTo(x + r, y + h);
  ctx.quadraticCurveTo(x, y + h, x, y + h - r);
  ctx.lineTo(x, y + r);
  ctx.quadraticCurveTo(x, y, x + r, y);
  ctx.closePath();
  ctx.fillStyle = color;
  ctx.fill();
}

function showMenu() {
  // End the current game and show the game over screen
  endGame();
}

function updateToggleButton() {
  const bgToggle = document.getElementById('bgToggle');
  if (backgroundEnabled) {
    bgToggle.textContent = "Background: ON";
    bgToggle.classList.remove('off');
  } else {
    bgToggle.textContent = "Background: OFF";
    bgToggle.classList.add('off');
  }
}

function toggleBackground() {
  backgroundEnabled = !backgroundEnabled;
  localStorage.setItem("backgroundEnabled", backgroundEnabled);
  updateToggleButton();
  
  // Force immediate redraw to show the change
  if (!gameRunning) {
    // If we're on the game over screen, redraw the background
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    drawBackground();
  }
}

function initBackground() {
  mountains = [];
  clouds = [];
  
  // Create multiple layers of mountains for parallax effect
  for (let i = 0; i < 3; i++) {
    let layer = [];
    let count = 5 + i * 2; // More mountains in foreground layers
    let heightFactor = 0.3 + i * 0.2; // Higher layers are taller
    let speedFactor = 0.2 + i * 0.2; // Closer layers move faster
    
    for (let j = 0; j < count; j++) {
      let x = (canvas.width / count) * j;
      let width = 100 + Math.random() * 150;
      let height = canvas.height * heightFactor;
      
      layer.push({
        x: x,
        y: canvas.height - height,
        width: width,
        height: height,
        speed: speedFactor,
        color: getMountainColor(i)
      });
    }
    mountains.push(layer);
  }
  
  // Create clouds
  for (let i = 0; i < 8; i++) {
    clouds.push({
      x: Math.random() * canvas.width,
      y: Math.random() * canvas.height * 0.5,
      width: 60 + Math.random() * 100,
      height: 30 + Math.random() * 40,
      speed: 0.2 + Math.random() * 0.3
    });
  }
}

function getMountainColor(layer) {
  // Different colors for different mountain layers - made more subtle
  const colors = [
    ['rgba(93, 138, 168, 0.4)', 'rgba(74, 112, 139, 0.4)', 'rgba(54, 100, 139, 0.4)'], // Layer 0 (farthest)
    ['rgba(107, 142, 35, 0.4)', 'rgba(85, 107, 47, 0.4)', 'rgba(107, 142, 35, 0.4)'], // Layer 1
    ['rgba(139, 115, 85, 0.4)', 'rgba(139, 69, 19, 0.4)', 'rgba(160, 82, 45, 0.4)']  // Layer 2 (closest)
  ];
  return colors[layer][Math.floor(Math.random() * colors[layer].length)];
}

function updateBackground() {
  if (!backgroundEnabled) return;
  
  // Update mountain positions for parallax scrolling
  for (let i = 0; i < mountains.length; i++) {
    let layer = mountains[i];
    for (let j = 0; j < layer.length; j++) {
      let mountain = layer[j];
      mountain.x -= scrollSpeed * mountain.speed;
      
      // If mountain goes off screen, move it to the right
      if (mountain.x + mountain.width < 0) {
        mountain.x = canvas.width;
      }
    }
  }
  
  // Update cloud positions
  for (let i = 0; i < clouds.length; i++) {
    let cloud = clouds[i];
    cloud.x -= cloud.speed;
    
    // If cloud goes off screen, move it to the right
    if (cloud.x + cloud.width < 0) {
      cloud.x = canvas.width;
      cloud.y = Math.random() * canvas.height * 0.5;
    }
  }
}

function drawBackground() {
  if (!backgroundEnabled) {
    // Draw simple gradient background when background is disabled
    let gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
    gradient.addColorStop(0, '#87CEEB');
    gradient.addColorStop(1, '#E0F7FA');
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    return;
  }
  
  // Draw gradient background based on selected theme
  const theme = themes[currentTheme];
  let gradient;
  
  if (currentTheme === 'night') {
    // Special handling for night theme with 3 colors
    gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
    gradient.addColorStop(0, theme.top);
    gradient.addColorStop(0.5, theme.mid);
    gradient.addColorStop(1, theme.bottom);
  } else {
    gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
    gradient.addColorStop(0, theme.top);
    gradient.addColorStop(1, theme.bottom);
  }
  
  ctx.fillStyle = gradient;
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  
  // Draw mountains (from farthest to closest)
  for (let i = 0; i < mountains.length; i++) {
    let layer = mountains[i];
    for (let j = 0; j < layer.length; j++) {
      let mountain = layer[j];
      
      // Draw mountain shape
      ctx.fillStyle = mountain.color;
      ctx.beginPath();
      ctx.moveTo(mountain.x, mountain.y + mountain.height);
      ctx.lineTo(mountain.x + mountain.width / 2, mountain.y);
      ctx.lineTo(mountain.x + mountain.width, mountain.y + mountain.height);
      ctx.closePath();
      ctx.fill();
      
      // Add some texture/details (more subtle)
      ctx.fillStyle = darkenColor(mountain.color, 10);
      ctx.beginPath();
      ctx.moveTo(mountain.x + mountain.width * 0.3, mountain.y + mountain.height * 0.3);
      ctx.lineTo(mountain.x + mountain.width * 0.5, mountain.y + mountain.height * 0.1);
      ctx.lineTo(mountain.x + mountain.width * 0.7, mountain.y + mountain.height * 0.3);
      ctx.closePath();
      ctx.fill();
    }
  }
  
  // Draw clouds (more subtle)
  ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
  for (let i = 0; i < clouds.length; i++) {
    let cloud = clouds[i];
    
    // Draw cloud with multiple circles for a fluffy look
    ctx.beginPath();
    ctx.arc(cloud.x, cloud.y, cloud.height / 2, 0, Math.PI * 2);
    ctx.arc(cloud.x + cloud.width * 0.3, cloud.y - cloud.height * 0.1, cloud.height * 0.6, 0, Math.PI * 2);
    ctx.arc(cloud.x + cloud.width * 0.6, cloud.y, cloud.height / 2, 0, Math.PI * 2);
    ctx.arc(cloud.x + cloud.width * 0.3, cloud.y + cloud.height * 0.1, cloud.height * 0.5, 0, Math.PI * 2);
    ctx.fill();
  }
}

function darkenColor(color, percent) {
  // Handle rgba colors
  if (color.includes('rgba')) {
    const rgba = color.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*([\d.]+))?\)/);
    if (rgba) {
      let r = parseInt(rgba[1]);
      let g = parseInt(rgba[2]);
      let b = parseInt(rgba[3]);
      let a = rgba[4] ? parseFloat(rgba[4]) : 1;
      
      // Darken
      r = Math.max(0, r - (r * percent / 100));
      g = Math.max(0, g - (g * percent / 100));
      b = Math.max(0, b - (b * percent / 100));
      
      return `rgba(${Math.round(r)}, ${Math.round(g)}, ${Math.round(b)}, ${a})`;
    }
  }
  
  // Handle hex colors
  const r = parseInt(color.substring(1, 3), 16);
  const g = parseInt(color.substring(3, 5), 16);
  const b = parseInt(color.substring(5, 7), 16);
  
  // Darken
  const newR = Math.max(0, r - (r * percent / 100));
  const newG = Math.max(0, g - (g * percent / 100));
  const newB = Math.max(0, b - (b * percent / 100));
  
  // Convert back to hex
  return '#' + 
    (newR < 16 ? '0' : '') + Math.round(newR).toString(16) +
    (newG < 16 ? '0' : '') + Math.round(newG).toString(16) +
    (newB < 16 ? '0' : '') + Math.round(newB).toString(16);
}

function handleKeyDown(e){
  if((e.code==="Space"||e.code==="ArrowUp") && player.onGround && !player.jumpHeld && gameRunning){
    player.jumpHeld = true;
    player.jumpFrameCount = 0;
    player.dy = player.minJumpPower;
    player.onGround = false;
    player.hasJumped = true;
    currentGameJumps++;
    spawnLandingParticles(player.x+player.width/2, player.y+player.height);
  }
}

function handleMouseDown(e){
  if(player.onGround && !player.jumpHeld && gameRunning){
    player.jumpHeld = true;
    player.jumpFrameCount = 0;
    player.dy = player.minJumpPower;
    player.onGround = false;
    player.hasJumped = true;
    currentGameJumps++;
    spawnLandingParticles(player.x+player.width/2, player.y+player.height);
  }
}

function handleKeyUp(e){ if((e.code==="Space"||e.code==="ArrowUp") && player.jumpHeld){ player.jumpHeld=false; player.jumpFrameCount=0; } }
function handleMouseUp(e){ if(player.jumpHeld){ player.jumpHeld=false; player.jumpFrameCount=0; } }

function resizeCanvas(){ 
  if(canvas){ 
    canvas.width = window.innerWidth; 
    canvas.height = window.innerHeight; 
    if(gameRunning && player) player.y = canvas.height - 150; 
    initBackground(); // Reinitialize background on resize
  } 
}
function resetGame(){ initGame(); }

function createInitialPlatforms(){
  platforms.push({x:canvas.width/2-200,y:canvas.height-100,width:400,height:20,color:"#4CAF50",type:"normal",spikePositions:[]});
  let lastX=platforms[0].x+platforms[0].width;
  let lastY=platforms[0].y;
  for(let i=0;i<8;i++){
    let nextY=lastY+(Math.random()*100-50);
    nextY=Math.max(canvas.height-300,Math.min(canvas.height-80,nextY));
    let width=platformMinWidth+Math.random()*(platformMaxWidth-platformMinWidth);
    let type=Math.random()<0.3?"falling":"normal"; 
    let color=type==="falling"?"#FF3B3B":"#4CAF50";
    let spikePositions=[];
    if(Math.random()<0.3){ 
      let clusterSize=Math.floor(4+Math.random()*2); 
      let startX=Math.random()*(width-10*clusterSize);
      for(let s=0;s<clusterSize;s++){ spikePositions.push(startX+s*10); }
    }
    platforms.push({x:lastX+platformGap,y:nextY,width:width,height:20,color:color,type:type,isFalling:false,spikePositions:spikePositions});
    lastX=platforms[platforms.length-1].x; lastY=platforms[platforms.length-1].y;
  }
}

function drawRoundedRect(x,y,w,h,r,color){
  ctx.beginPath(); ctx.moveTo(x+r,y); ctx.lineTo(x+w-r,y); ctx.quadraticCurveTo(x+w,y,x+w,y+r); ctx.lineTo(x+w,y+h-r); ctx.quadraticCurveTo(x+w,y+h,x+w-r,y+h); ctx.lineTo(x+r,y+h); ctx.quadraticCurveTo(x,y+h,x,y+h-r); ctx.lineTo(x,y+r); ctx.quadraticCurveTo(x,y,x+r,y); ctx.closePath(); ctx.fillStyle=color; ctx.fill();
}
function drawPlayer(){
  ctx.save(); ctx.translate(player.x+player.width/2,player.y+player.height/2); ctx.rotate(player.dy*0.03); drawRoundedRect(-player.width/2,-player.height/2,player.width,player.height,10,player.color);
  ctx.fillStyle="#333"; ctx.beginPath(); ctx.arc(-player.width/2+player.width*0.7,-player.height/2+player.height*0.3,5,0,Math.PI*2); ctx.fill();
  ctx.fillStyle="#FFF"; ctx.beginPath(); ctx.arc(-player.width/2+player.width*0.68,-player.height/2+player.height*0.28,2,0,Math.PI*2); ctx.fill();
  ctx.restore();
}
function drawPlatform(p){
  drawRoundedRect(p.x,p.y,p.width,p.height,10,p.color);
  ctx.fillStyle="#388E3C"; ctx.fillRect(p.x,p.y,p.width,5);
  if(p.spikePositions.length>0){
    ctx.fillStyle="#FF0000";
    for(let pos of p.spikePositions){ ctx.beginPath(); ctx.moveTo(p.x+pos,p.y); ctx.lineTo(p.x+pos+5,p.y-10); ctx.lineTo(p.x+pos+10,p.y); ctx.closePath(); ctx.fill(); }
  }
}

function spawnLandingParticles(x,y){ for(let i=0;i<6;i++){ particles.push({x:x,y:y,dx:(Math.random()-0.5)*4,dy:Math.random()*-2,alpha:1,radius:2+Math.random()*2}); } }
function updateParticles(){ for(let i=particles.length-1;i>=0;i--){ let p=particles[i]; p.x+=p.dx; p.y+=p.dy; p.dy+=0.1; p.alpha-=0.03; if(p.alpha<=0) particles.splice(i,1); else{ctx.fillStyle=`rgba(255,255,255,${p.alpha})`; ctx.beginPath(); ctx.arc(p.x,p.y,p.radius,0,Math.PI*2); ctx.fill();} } }

function gameLoop(){
  if(!gameRunning) return;
  ctx.clearRect(0,0,canvas.width,canvas.height);
  
  // Update and draw background
  updateBackground();
  drawBackground();

  player.dy += player.gravity; 
  player.y += player.dy; 
  player.onGround = false;

  // Extra lift while holding jump, only during current jump
  if(player.jumpHeld && player.jumpFrameCount < 20 && player.hasJumped){
      player.jumpFrameCount++;
      const holdFactor = Math.min(1, player.jumpFrameCount / 20);
      const extraLift = (player.maxJumpPower - player.minJumpPower) * 0.15 * (1 - holdFactor);
      player.dy = Math.max(player.dy + extraLift, player.maxJumpCap);
  }

  // Platform collision
  for(let plat of platforms){
    if(player.x < plat.x+plat.width && player.x+player.width > plat.x &&
       player.y+player.height > plat.y && player.y+player.height < plat.y+plat.height+player.dy){
      player.y = plat.y - player.height; 
      player.dy = 0; 
      player.onGround = true; 
      player.hasJumped = false;  // reset jump ability only on landing
      spawnLandingParticles(player.x+player.width/2, plat.y);
      if(plat.type==="falling" && !plat.isFalling){ plat.isFalling=true; setTimeout(()=>{plat.dy=2;},100);}
    }

    for(let pos of plat.spikePositions){
      if(player.x+player.width > plat.x+pos && player.x < plat.x+pos+10 && player.y+player.height > plat.y-10){ endGame(); return; }
    }
  }

  for(let plat of platforms){ plat.x -= scrollSpeed; if(plat.isFalling) plat.y += (plat.dy||0); }

  score += scrollSpeed; 
  document.getElementById('score').textContent = 'Score: ' + Math.floor(score/10);
  if(Math.floor(score/10) > highScore){ 
    highScore = Math.floor(score/10); 
    localStorage.setItem("highScore", highScore); 
    document.getElementById('highScore').textContent = "High Score: " + highScore; 
  }

let difficulty = Math.floor(score / 1000);
scrollSpeed = 4 + difficulty*0.5;
platformMinWidth = Math.max(60, 120 - difficulty*5);

  platforms = platforms.filter(p=>p.x+p.width>0 && p.y<canvas.height+100);

  if(platforms.length < 10){
    let lastPlat = platforms[platforms.length-1];
    let nextY = lastPlat.y + (Math.random()*100-50); 
    nextY = Math.max(canvas.height-300, Math.min(canvas.height-80, nextY));
    let width = platformMinWidth + Math.random()*(platformMaxWidth-platformMinWidth);
    let type = Math.random()<0.3?"falling":"normal"; 
    let color = type==="falling"?"#FF3B3B":"#4CAF50";
    let spikePositions = [];
    if(Math.random()<0.3){ 
      let clusterSize = Math.floor(4+Math.random()*2); 
      let startX = Math.random()*(width-10*clusterSize); 
      for(let s=0;s<clusterSize;s++){ spikePositions.push(startX+s*10); } 
    }
    platforms.push({x:lastPlat.x+platformGap, y:nextY, width:width, height:20, color:color, type:type, isFalling:false, spikePositions:spikePositions});
  }

  for(let plat of platforms) drawPlatform(plat);
  drawPlayer();
  updateParticles();

  if(player.y>canvas.height){ endGame(); return; }

  animationId = requestAnimationFrame(gameLoop);
}

function endGame(){
  gameRunning = false;
  
  // Update total jumps count
  totalJumps += currentGameJumps;
  localStorage.setItem("totalJumps", totalJumps);
  
  // Update game over screen
  document.getElementById('finalScore').textContent = Math.floor(score/10);
  document.getElementById('finalHighScore').textContent = highScore;
  document.getElementById('totalJumps').textContent = totalJumps;
  document.getElementById('gameOver').style.display = 'block';
  
  // Update character selection to show current color
  setupCharacterSelection();
  
  // Update theme selection
  setupThemeSelection();
}

window.onload = initGame;
</script>
</body>
</html>
